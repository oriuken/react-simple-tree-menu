{"version":3,"file":"main.3e77d1f2d4b2ebc0a537.bundle.js","sources":["webpack:///./src/TreeMenu/walk.tsx"],"sourcesContent":["import { isEmpty } from 'lodash';\nimport memoize from 'fast-memoize';\n\nexport interface TreeNodeObject {\n  [name: string]: TreeNode;\n}\n\ninterface LocaleFunctionProps {\n  label: string;\n  [name: string]: any;\n}\n\ninterface MatchSearchFunctionProps extends LocaleFunctionProps {\n  searchTerm: string;\n}\n\nexport interface TreeNode extends LocaleFunctionProps {\n  index: number;\n  nodes?: TreeNodeObject;\n}\n\nexport interface TreeNodeInArray extends LocaleFunctionProps {\n  key: string;\n  nodes?: TreeNodeInArray[];\n}\n\nexport type LocaleFunction = (localeFunctionProps: LocaleFunctionProps) => string;\nexport type MatchSearchFunction = (\n  matchSearchFunctionProps: MatchSearchFunctionProps\n) => boolean;\n\ntype Data = TreeNodeObject | TreeNodeInArray[];\ninterface WalkProps {\n  data: Data | undefined;\n  parent?: string;\n  level?: number;\n  openNodes: string[];\n  searchTerm: string;\n  locale?: LocaleFunction;\n  matchSearch?: MatchSearchFunction;\n}\n\ninterface BranchProps {\n  parent: string;\n  level: number;\n  openNodes: string[];\n  searchTerm: string;\n  node: TreeNode | TreeNodeInArray;\n  nodeName: string;\n  index?: number;\n  locale?: LocaleFunction;\n  matchSearch?: MatchSearchFunction;\n}\n\nexport interface Item {\n  hasNodes: boolean;\n  isOpen: boolean;\n  level: number;\n  key: string;\n  label: string;\n  [name: string]: any;\n}\n\nconst validateData = (data: Data | undefined): boolean => !!data && !isEmpty(data);\nconst getValidatedData = (data: Data | undefined) =>\n  validateData(data) ? (data as Data) : [];\n\nconst walk = ({ data, ...props }: WalkProps): Item[] => {\n  const validatedData = getValidatedData(data);\n\n  const propsWithDefaultValues = { parent: '', level: 0, ...props };\n  const handleArray = (dataAsArray: TreeNodeInArray[]) =>\n    dataAsArray.reduce((all: Item[], node: TreeNodeInArray, index) => {\n      const branchProps = { node, index, nodeName: node.key, ...propsWithDefaultValues };\n      const branch = generateBranch(branchProps);\n      return [...all, ...branch];\n    }, []);\n\n  const handleObject = (dataAsObject: TreeNodeObject) =>\n    Object.entries(dataAsObject)\n      .sort((a, b) => a[1].index - b[1].index) // sorted by index\n      .reduce((all: Item[], [nodeName, node]: [string, TreeNode]) => {\n        const branchProps = { node, nodeName, ...propsWithDefaultValues };\n        const branch = generateBranch(branchProps);\n        return [...all, ...branch];\n      }, []);\n\n  return Array.isArray(validatedData)\n    ? handleArray(validatedData)\n    : handleObject(validatedData);\n};\n\nconst defaultMatchSearch = ({ label, searchTerm }: MatchSearchFunctionProps) => {\n  const processString = (text: string): string => text.trim().toLowerCase();\n  return processString(label).includes(processString(searchTerm));\n};\n\nconst defaultLocale = ({ label }: LocaleFunctionProps): string => label;\n\nconst generateBranch = ({\n  node,\n  nodeName,\n  matchSearch = defaultMatchSearch,\n  locale = defaultLocale,\n  ...props\n}: BranchProps): Item[] => {\n  const { parent, level, openNodes, searchTerm } = props;\n\n  const { nodes, label: rawLabel = 'unknown', ...nodeProps } = node;\n  const key = [parent, nodeName].filter(x => x).join('/');\n  const hasNodes = validateData(nodes);\n  const isOpen = hasNodes && (openNodes.includes(key) || !!searchTerm);\n\n  const label = locale({ label: rawLabel, ...nodeProps });\n  const isVisible = !searchTerm || matchSearch({ label, searchTerm, ...nodeProps });\n  const currentItem = { ...props, ...nodeProps, label, hasNodes, isOpen, key };\n\n  const data = getValidatedData(nodes);\n  const nextLevelItems = isOpen\n    ? walk({ data, locale, matchSearch, ...props, parent: key, level: level + 1 })\n    : [];\n\n  return isVisible ? [currentItem, ...nextLevelItems] : nextLevelItems;\n};\n\nexport default memoize(walk);\n"],"mappings":"AACA","sourceRoot":""}